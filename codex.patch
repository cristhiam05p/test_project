diff --git a/src/components/DepartmentSection.tsx b/src/components/DepartmentSection.tsx
index 2c8b91198fcfd8c3422b9dfa81b4f4d46166ed25..6b3876d211ff9c46e9e3241580b350877aa2c42a 100644
--- a/src/components/DepartmentSection.tsx
+++ b/src/components/DepartmentSection.tsx
@@ -1,47 +1,50 @@
 import type { WorkPackage } from "../types/workPackage";
 import type { EmployeeGroup } from "../utils/timelineUtils";
 import { EmployeeRow } from "./EmployeeRow";
 
 interface DepartmentSectionProps {
   department: string;
   employees: EmployeeGroup[];
   timelineStartDate: string;
   timelineDays: number;
   dayWidths: number[];
   cumulativeOffsets: number[];
   totalTimelineWidth: number;
+  nonWorkingDayByIndex: boolean[];
   onTaskSelect: (task: WorkPackage) => void;
   onEmployeeSelect: (employeeId: string) => void;
 }
 
 export const DepartmentSection = ({
   department,
   employees,
   timelineStartDate,
   timelineDays,
   dayWidths,
   cumulativeOffsets,
   totalTimelineWidth,
+  nonWorkingDayByIndex,
   onTaskSelect,
   onEmployeeSelect,
 }: DepartmentSectionProps) => {
   return (
     <section className="department-section">
       <h2>{department}</h2>
       {employees.map((employee) => (
         <EmployeeRow
           key={employee.employeeId}
           employeeName={employee.employeeName}
           tasks={employee.tasks}
           timelineStartDate={timelineStartDate}
           timelineDays={timelineDays}
           dayWidths={dayWidths}
           cumulativeOffsets={cumulativeOffsets}
           totalTimelineWidth={totalTimelineWidth}
+          nonWorkingDayByIndex={nonWorkingDayByIndex}
           onTaskSelect={onTaskSelect}
           onEmployeeSelect={() => onEmployeeSelect(employee.employeeId)}
         />
       ))}
     </section>
   );
 };
diff --git a/src/components/EmployeeRow.tsx b/src/components/EmployeeRow.tsx
index a566fd1803fb3f8fea7a290a3958d21c8a0ca797..3fdff3c8329d47d739dd429f8e2ae0c9f9caf26f 100644
--- a/src/components/EmployeeRow.tsx
+++ b/src/components/EmployeeRow.tsx
@@ -1,54 +1,56 @@
 import type { WorkPackage } from "../types/workPackage";
 import { TaskBlock } from "./TaskBlock";
 
 interface EmployeeRowProps {
   employeeName: string;
   tasks: WorkPackage[];
   timelineStartDate: string;
   timelineDays: number;
   dayWidths: number[];
   cumulativeOffsets: number[];
   totalTimelineWidth: number;
+  nonWorkingDayByIndex: boolean[];
   onTaskSelect: (task: WorkPackage) => void;
   onEmployeeSelect: () => void;
 }
 
 export const EmployeeRow = ({
   employeeName,
   tasks,
   timelineStartDate,
   timelineDays,
   dayWidths,
   cumulativeOffsets,
   totalTimelineWidth,
+  nonWorkingDayByIndex,
   onTaskSelect,
   onEmployeeSelect,
 }: EmployeeRowProps) => {
   return (
     <div className="employee-row">
       <button className="employee-label employee-button" onClick={onEmployeeSelect} type="button">
         {employeeName}
       </button>
       <div className="employee-timeline" style={{ width: totalTimelineWidth }}>
         {Array.from({ length: timelineDays }, (_, index) => (
           <div
             key={index}
-            className="day-cell"
+            className={`day-cell ${nonWorkingDayByIndex[index] ? "non-working-day" : ""}`}
             style={{ width: dayWidths[index], left: cumulativeOffsets[index] }}
           />
         ))}
         {tasks.map((task) => (
           <TaskBlock
             key={task.id}
             task={task}
             timelineStartDate={timelineStartDate}
             dayWidth={dayWidths[0]}
             dayWidths={dayWidths}
             cumulativeOffsets={cumulativeOffsets}
             onSelect={onTaskSelect}
           />
         ))}
       </div>
     </div>
   );
 };
diff --git a/src/components/ResourceTimeline.tsx b/src/components/ResourceTimeline.tsx
index 0b97b732c82156a968ec6c4d3328c062093b88f4..ac965c10feb6710dace8b8543058315f44e336c0 100644
--- a/src/components/ResourceTimeline.tsx
+++ b/src/components/ResourceTimeline.tsx
@@ -1,66 +1,66 @@
 import { useMemo, useState } from "react";
 import type { EmployeeProfile } from "../data/mock-data";
 import type { WorkPackage } from "../types/workPackage";
 import {
   formatDayLabel,
   formatDayMonth,
   getDayRange,
   getWeekHeaderGroups,
   getWeekLabel,
+  isHolidayBW,
+  isWeekend,
 } from "../utils/dateUtils";
 import { includesNormalized } from "../utils/textUtils";
 import { groupByDepartmentAndEmployee } from "../utils/timelineUtils";
 import { DepartmentSection } from "./DepartmentSection";
 import { EmployeeDetailsModal } from "./EmployeeDetailsModal";
 import { TaskDetailsModal } from "./TaskDetailsModal";
 
 interface ResourceTimelineProps {
   tasks: WorkPackage[];
   employees: EmployeeProfile[];
   timelineStartDate: string;
   timelineDays?: number;
 }
 
 const DAY_WIDTH = 42;
-const EXPANDED_DAY_WIDTH = 72;
 const WEEK_RANGE_MIN_WIDTH = 150;
 
 const getCompactDayLabel = (day: Date): string =>
   day.toLocaleDateString("es-ES", { day: "2-digit" });
 
 export const ResourceTimeline = ({
   tasks,
   employees,
   timelineStartDate,
   timelineDays = 28,
 }: ResourceTimelineProps) => {
   const [selectedTask, setSelectedTask] = useState<WorkPackage | null>(null);
   const [selectedEmployeeId, setSelectedEmployeeId] = useState<string | null>(null);
   const [selectedDepartment, setSelectedDepartment] = useState<string>("Todos");
   const [employeeQuery, setEmployeeQuery] = useState<string>("");
-  const [expandedWeekKey, setExpandedWeekKey] = useState<string | null>(null);
 
   const departments = useMemo(
     () => ["Todos", ...new Set(tasks.map((task) => task.department))],
     [tasks],
   );
 
   const projectLegend = useMemo(() => {
     const projects = new Map<
       string,
       { projectName: string; projectColor: string }
     >();
     tasks.forEach((task) => {
       projects.set(task.projectId, {
         projectName: task.projectName,
         projectColor: task.projectColor,
       });
     });
     return [...projects.entries()].map(([projectId, data]) => ({
       projectId,
       ...data,
     }));
   }, [tasks]);
 
   const filteredTasks = useMemo(() => {
     return tasks.filter((task) => {
@@ -71,74 +71,71 @@ export const ResourceTimeline = ({
       const matchesSearch =
         includesNormalized(task.employeeName, employeeQuery) ||
         includesNormalized(task.title, employeeQuery) ||
         includesNormalized(task.description, employeeQuery) ||
         includesNormalized(task.projectName, employeeQuery);
 
       return matchesDepartment && matchesSearch;
     });
   }, [tasks, selectedDepartment, employeeQuery]);
 
   const groupedData = useMemo(
     () => groupByDepartmentAndEmployee(filteredTasks),
     [filteredTasks],
   );
 
   const dayRange = useMemo(
     () => getDayRange(timelineStartDate, timelineDays),
     [timelineDays, timelineStartDate],
   );
 
   const weekHeaderGroups = useMemo(
     () => getWeekHeaderGroups(dayRange),
     [dayRange],
   );
 
-  // Decisión: modo accordion para KW (solo una semana expandida a la vez).
-  const dayWidths = useMemo(() => {
-    const weekByDay = dayRange.map((day) => {
-      const matchingWeek = weekHeaderGroups.find((group) => day >= group.weekStart && day <= group.weekEnd);
-      return matchingWeek?.key;
-    });
-
-    return weekByDay.map((weekKey) => (weekKey && weekKey === expandedWeekKey ? EXPANDED_DAY_WIDTH : DAY_WIDTH));
-  }, [dayRange, weekHeaderGroups, expandedWeekKey]);
+  const dayWidths = useMemo(() => dayRange.map(() => DAY_WIDTH), [dayRange]);
 
   const cumulativeOffsets = useMemo(() => {
     let acc = 0;
     return dayWidths.map((width) => {
       const left = acc;
       acc += width;
       return left;
     });
   }, [dayWidths]);
 
   const totalTimelineWidth = useMemo(
     () => dayWidths.reduce((sum, width) => sum + width, 0),
     [dayWidths],
   );
 
+  const nonWorkingDayByIndex = useMemo(
+    () => dayRange.map((day) => isWeekend(day) || isHolidayBW(day)),
+    [dayRange],
+  );
+
   const taskTitleById = useMemo(() => {
     return new Map(tasks.map((task) => [task.id, task.title]));
   }, [tasks]);
 
   const selectedEmployee = useMemo(
     () => employees.find((employee) => employee.employeeId === selectedEmployeeId) ?? null,
     [employees, selectedEmployeeId],
   );
 
   const selectedEmployeeTasks = useMemo(
     () => tasks.filter((task) => task.employeeId === selectedEmployeeId),
     [tasks, selectedEmployeeId],
   );
 
   return (
     <div className="resource-timeline-page">
       <header>
         <h1>Vista Recursos (MVP)</h1>
         <p>
           Visualización por departamento y empleado para saber quién está
           haciendo qué y cuándo.
         </p>
       </header>
 
       <section className="filters">
@@ -174,98 +171,96 @@ export const ResourceTimeline = ({
               aria-hidden="true"
             />
             {project.projectName}
           </span>
         ))}
       </section>
 
       <div className="timeline-shell">
         <div className="timeline-header">
           <div className="employee-label header">Departamento / Empleado</div>
 
           <div
             className="timeline-days"
             style={{ width: totalTimelineWidth }}
           >
             <div className="week-header-row">
               {weekHeaderGroups.map((weekGroup) => {
                 const weekDays = dayRange.filter(
                   (day) => day >= weekGroup.weekStart && day <= weekGroup.weekEnd,
                 );
                 const weekWidth = weekDays.reduce((sum, day) => {
                   const dayIndex = dayRange.indexOf(day);
                   return sum + dayWidths[dayIndex];
                 }, 0);
                 const showWeekRange = weekWidth >= WEEK_RANGE_MIN_WIDTH;
-                const isActive = expandedWeekKey === weekGroup.key;
 
                 return (
-                  <button
+                  <div
                     key={weekGroup.key}
-                    className={`week-header ${isActive ? "week-header--active" : ""}`}
+                    className="week-header"
                     style={{ width: weekWidth }}
-                    type="button"
-                    onClick={() => setExpandedWeekKey((current) => (current === weekGroup.key ? null : weekGroup.key))}
                   >
                     <strong className="week-label">{getWeekLabel(weekGroup.weekStart)}</strong>
                     {showWeekRange ? (
                       <span className="week-range">
                         ({formatDayMonth(weekGroup.weekStart)} -{" "}
                         {formatDayMonth(weekGroup.weekEnd)})
                       </span>
                     ) : null}
-                  </button>
+                  </div>
                 );
               })}
             </div>
 
             <div className="day-header-row">
               {dayRange.map((day, index) => (
                 <div
                   key={index}
-                  className="day-header"
+                  className={`day-header ${nonWorkingDayByIndex[index] ? "non-working-day" : ""}`}
                   style={{ width: dayWidths[index] }}
                 >
                   <span className="day-label day-label--default">{formatDayLabel(day)}</span>
                   <span className="day-label day-label--compact">{getCompactDayLabel(day)}</span>
                 </div>
               ))}
             </div>
           </div>
         </div>
 
         {groupedData.length === 0 ? (
           <p className="empty-state">No hay tareas con los filtros actuales.</p>
         ) : (
           groupedData.map((department) => (
             <DepartmentSection
               key={department.department}
               department={department.department}
               employees={department.employees}
               timelineStartDate={timelineStartDate}
               timelineDays={timelineDays}
               dayWidths={dayWidths}
               cumulativeOffsets={cumulativeOffsets}
               totalTimelineWidth={totalTimelineWidth}
+              nonWorkingDayByIndex={nonWorkingDayByIndex}
               onTaskSelect={setSelectedTask}
               onEmployeeSelect={setSelectedEmployeeId}
             />
           ))
         )}
       </div>
 
       <TaskDetailsModal
         task={selectedTask}
         taskTitleById={taskTitleById}
         onClose={() => setSelectedTask(null)}
       />
 
       <EmployeeDetailsModal
         employee={selectedEmployee}
         tasks={selectedEmployeeTasks}
         timelineStartDate={timelineStartDate}
         timelineDays={timelineDays}
         onClose={() => setSelectedEmployeeId(null)}
       />
     </div>
   );
 };
diff --git a/src/components/TaskBlock.tsx b/src/components/TaskBlock.tsx
index 67671c5ddfe23d703a0f2070ed13f1a0ed115ce6..3a101847fe0104998f5afb0a10beafb205fa9af3 100644
--- a/src/components/TaskBlock.tsx
+++ b/src/components/TaskBlock.tsx
@@ -1,47 +1,51 @@
 import type { WorkPackage } from "../types/workPackage";
+import { addWorkingDays, differenceInDays, toDate } from "../utils/dateUtils";
 import { getTaskOffsetDays } from "../utils/timelineUtils";
 
 interface TaskBlockProps {
   task: WorkPackage;
   timelineStartDate: string;
   dayWidth: number;
   dayWidths?: number[];
   cumulativeOffsets?: number[];
   onSelect: (task: WorkPackage) => void;
 }
 
 export const TaskBlock = ({
   task,
   timelineStartDate,
   dayWidth,
   dayWidths,
   cumulativeOffsets,
   onSelect,
 }: TaskBlockProps) => {
   const startOffset = getTaskOffsetDays(timelineStartDate, task.scheduledStartDate);
   const hasVariableWidths = dayWidths && cumulativeOffsets && dayWidths.length > 0;
+  const taskStart = toDate(task.scheduledStartDate);
+  const taskEndExclusive = addWorkingDays(taskStart, task.durationDays);
+  const taskSpanDays = Math.max(1, differenceInDays(taskStart, taskEndExclusive));
 
   const left = hasVariableWidths
     ? cumulativeOffsets[Math.max(0, startOffset)] ?? 0
     : startOffset * dayWidth;
 
   const width = hasVariableWidths
-    ? Array.from({ length: task.durationDays }, (_, index) => dayWidths[startOffset + index] ?? 0).reduce(
+    ? Array.from({ length: taskSpanDays }, (_, index) => dayWidths[startOffset + index] ?? 0).reduce(
         (total, current) => total + current,
         0,
       )
-    : task.durationDays * dayWidth;
+    : taskSpanDays * dayWidth;
 
   return (
     <button
       className="task-block"
       style={{ left, width, background: task.projectColor }}
       onClick={() => onSelect(task)}
       title={`${task.title} (${task.projectName})`}
       type="button"
     >
       <span className="task-block-title">{task.title}</span>
       <span className="task-block-project">{task.projectName}</span>
     </button>
   );
 };
diff --git a/src/data/mock-data.ts b/src/data/mock-data.ts
index 3ef46603e4c6a122c2c204f04fb5ffd5170449b4..8d15c2a6c0544fa4430af9f153e5e206a57f7158 100644
--- a/src/data/mock-data.ts
+++ b/src/data/mock-data.ts
@@ -1,26 +1,33 @@
-import { addDays, formatISODate, toDate } from "../utils/dateUtils";
+import {
+  addDays,
+  addWorkingDays,
+  formatISODate,
+  getNextWorkingDay,
+  isWorkingDay,
+  toDate,
+} from "../utils/dateUtils";
 import type { WorkPackage } from "../types/workPackage";
 
 export interface EmployeeProfile {
   employeeId: string;
   employeeName: string;
   department: string;
   role: string;
   hourlyCost: number;
   weeklyCapacityHours: number;
   absences: { startDate: string; endDate: string; reason: string }[];
 }
 
 export const demoStartDate = "2026-02-02";
 export const timelineWeeks = 12;
 
 export const projectCatalog = {
   "P-RHEIN": { name: "Project Rhein", color: "#2563eb" },
   "P-ANDEN": { name: "Project Anden", color: "#0f766e" },
   "P-AURORA": { name: "Project Aurora", color: "#7c3aed" },
   "P-ATLAS": { name: "Project Atlas", color: "#c2410c" },
   "P-DELTA": { name: "Project Delta", color: "#db2777" },
   "P-NOVA": { name: "Project Nova", color: "#0891b2" },
 } as const;
 
 type ProjectId = keyof typeof projectCatalog;
@@ -94,96 +101,153 @@ const taskDescriptions = [
   "Implementación incremental con foco en estabilidad y mantenibilidad.",
   "Cobertura de casos borde y definición de criterios de aceptación.",
   "Revisión cruzada entre equipos para minimizar bloqueos de dependencia.",
   "Preparación de demo ejecutiva con indicadores de avance.",
 ] as const;
 
 const createSeededRandom = (seed: number) => {
   let state = seed;
   return () => {
     state = (state * 1664525 + 1013904223) % 4294967296;
     return state / 4294967296;
   };
 };
 
 const rng = createSeededRandom(24022026);
 
 const randomInt = (min: number, max: number) =>
   Math.floor(rng() * (max - min + 1)) + min;
 
 const pickOne = <T,>(items: readonly T[]): T => {
   const index = Math.floor(rng() * items.length);
   return items[index];
 };
 
 const projectIds = Object.keys(projectCatalog) as ProjectId[];
+const TOTAL_TIMELINE_DAYS = timelineWeeks * 7;
+
+interface TaskSpan {
+  start: Date;
+  endExclusive: Date;
+}
+
+const getTaskEndExclusive = (start: Date, durationDays: number): Date => {
+  return addWorkingDays(start, durationDays);
+};
+
+const hasOverlap = (employeeTasks: TaskSpan[], candidate: TaskSpan): boolean => {
+  return employeeTasks.some(
+    (task) => candidate.start < task.endExclusive && candidate.endExclusive > task.start,
+  );
+};
+
+const placeTaskWithoutOverlap = (
+  existingTasks: TaskSpan[],
+  timelineStart: Date,
+  durationDays: number,
+): Date => {
+  const maxOffset = Math.max(0, TOTAL_TIMELINE_DAYS - 10);
+
+  for (let attempt = 0; attempt < 200; attempt += 1) {
+    const startOffset = randomInt(0, maxOffset);
+    const candidateStart = getNextWorkingDay(addDays(timelineStart, startOffset));
+    const candidateSpan: TaskSpan = {
+      start: candidateStart,
+      endExclusive: getTaskEndExclusive(candidateStart, durationDays),
+    };
+
+    if (!hasOverlap(existingTasks, candidateSpan)) {
+      return candidateStart;
+    }
+  }
+
+  const sortedTasks = [...existingTasks].sort(
+    (a, b) => a.start.getTime() - b.start.getTime(),
+  );
+  const tailDate = sortedTasks.length > 0 ? sortedTasks[sortedTasks.length - 1].endExclusive : timelineStart;
+  return getNextWorkingDay(tailDate);
+};
 
 const buildEmployeeProfiles = (): EmployeeProfile[] => {
   const output: EmployeeProfile[] = [];
 
   departments.forEach((department, departmentIndex) => {
     department.employees.forEach((employeeName, employeeIndex) => {
       const employeeId = `EMP-${department.name.slice(0, 2).toUpperCase()}-${String(employeeIndex + 1).padStart(2, "0")}`;
       const weeklyCapacityHours = randomInt(34, 40);
       const absenceStart = addDays(toDate(demoStartDate), randomInt(7, 60));
 
       output.push({
         employeeId,
         employeeName,
         department: department.name,
         role: department.roles[(employeeIndex + departmentIndex) % department.roles.length],
         hourlyCost: randomInt(28, 64),
         weeklyCapacityHours,
         absences:
           rng() > 0.45
             ? [
                 {
                   startDate: formatISODate(absenceStart),
                   endDate: formatISODate(addDays(absenceStart, randomInt(1, 3))),
                   reason: pickOne(["Vacaciones", "Formación", "Permiso"]) as string,
                 },
               ]
             : [],
       });
     });
   });
 
   return output;
 };
 
 export const employeeProfiles = buildEmployeeProfiles();
 
 const withProject = (
   projectId: ProjectId,
   task: Omit<WorkPackage, "projectId" | "projectName" | "projectColor">,
 ): WorkPackage => ({
   ...task,
   projectId,
   projectName: projectCatalog[projectId].name,
   projectColor: projectCatalog[projectId].color,
 });
 
-export const workPackages: WorkPackage[] = employeeProfiles.flatMap((employee, employeeIndex) => {
+export const workPackages: WorkPackage[] = employeeProfiles.flatMap((employee) => {
   const taskCount = randomInt(4, 8);
+  const employeeTimelineStart = toDate(demoStartDate);
+  const placedTasks: TaskSpan[] = [];
 
   return Array.from({ length: taskCount }, (_, taskIndex) => {
     const projectId = pickOne(projectIds);
-    const startOffset = randomInt(0, timelineWeeks * 7 - 14);
     const durationDays = randomInt(2, 6);
-    const startDate = addDays(toDate(demoStartDate), startOffset);
+    const startDate = placeTaskWithoutOverlap(
+      placedTasks,
+      employeeTimelineStart,
+      durationDays,
+    );
+    const endExclusive = getTaskEndExclusive(startDate, durationDays);
     const dependencyTaskId = taskIndex > 0 ? `${employee.employeeId}-TSK-${taskIndex}` : null;
 
+    placedTasks.push({ start: startDate, endExclusive });
+
+    const earliestCandidate = addWorkingDays(startDate, -randomInt(0, 2));
+    const earliestStartDate = isWorkingDay(earliestCandidate)
+      ? earliestCandidate
+      : getNextWorkingDay(earliestCandidate);
+    const deadlineDate = addWorkingDays(endExclusive, randomInt(1, 5));
+
     return withProject(projectId, {
       id: `${employee.employeeId}-TSK-${taskIndex + 1}`,
       department: employee.department,
       employeeId: employee.employeeId,
       employeeName: employee.employeeName,
       title: `${pickOne(taskTopics)} ${taskIndex + 1}`,
       description: `${pickOne(taskDescriptions)} Equipo: ${employee.department}.`,
-      earliestStartDate: formatISODate(addDays(startDate, -randomInt(0, 2))),
-      deadlineDate: formatISODate(addDays(startDate, durationDays + randomInt(2, 6))),
+      earliestStartDate: formatISODate(earliestStartDate),
+      deadlineDate: formatISODate(deadlineDate),
       durationDays,
       scheduledStartDate: formatISODate(startDate),
       dependencies: dependencyTaskId ? [{ type: pickOne(["FS", "SS"]), taskId: dependencyTaskId }] : [],
     });
   });
 });
diff --git a/src/styles.css b/src/styles.css
index 892f78fc9a052fd13f67135779f30098e325bbcb..c803336e5b4030906de4cf704d1a37302ba1e194 100644
--- a/src/styles.css
+++ b/src/styles.css
@@ -1,29 +1,34 @@
 :root {
   --timeline-row-height: 52px;
   --timeline-header-week-height: 30px;
   --timeline-header-day-height: 30px;
+  --timeline-sidebar-width: 220px;
+  --timeline-sticky-sidebar-z: 20;
+  --timeline-sticky-header-z: 16;
+  --timeline-sticky-corner-z: 24;
+  --timeline-non-working-bg: #dbeafe;
 
   font-family:
     system-ui,
     -apple-system,
     BlinkMacSystemFont,
     "Segoe UI",
     sans-serif;
   background: #f8fafc;
   color: #0f172a;
 }
 
 * {
   box-sizing: border-box;
 }
 
 body {
   margin: 0;
 }
 
 .resource-timeline-page {
   padding: 1.2rem;
 }
 
 header h1 {
   margin: 0;
@@ -64,187 +69,199 @@ header p {
   margin-bottom: 0.9rem;
 }
 
 .legend-item {
   display: inline-flex;
   align-items: center;
   gap: 0.45rem;
   font-size: 0.88rem;
   color: #334155;
 }
 
 .legend-item i,
 .project-chip i {
   width: 12px;
   height: 12px;
   border-radius: 50%;
   display: inline-block;
 }
 
 .timeline-shell {
   background: #fff;
   border: 1px solid #e2e8f0;
   border-radius: 12px;
   overflow: auto;
   max-height: calc(100vh - 260px);
+  position: relative;
 }
 
 .timeline-header {
   display: inline-flex;
   min-width: max-content;
   position: sticky;
   top: 0;
-  z-index: 8;
+  z-index: var(--timeline-sticky-header-z);
   background: #f1f5f9;
   border-bottom: 1px solid #cbd5e1;
 }
 
 .timeline-days {
   display: flex;
   flex-direction: column;
 }
 
 .week-header-row,
 .day-header-row {
   display: flex;
 }
 
 .week-header {
   border: 0;
   border-left: 1px solid #cbd5e1;
   padding: 0.35rem 0.25rem;
   min-height: var(--timeline-header-week-height);
   font-size: 0.7rem;
   display: flex;
   gap: 0.25rem;
   align-items: center;
   min-width: 0;
   overflow: hidden;
-  cursor: pointer;
+  cursor: default;
   background: #e2e8f0;
   text-align: left;
 }
 
-.week-header--active {
-  background: #cbd5e1;
-  outline: 2px solid #3b82f6;
-  outline-offset: -2px;
-}
-
 .week-label,
 .week-range {
   display: block;
   min-width: 0;
   overflow: hidden;
   text-overflow: ellipsis;
   white-space: nowrap;
 }
 
 .week-header strong {
   font-size: 0.72rem;
   flex: 0 1 auto;
 }
 
 .week-range {
   flex: 1 1 auto;
 }
 
 .day-header {
   border-left: 1px solid #cbd5e1;
   padding: 0.35rem 0.2rem;
   font-size: 0.7rem;
   min-height: var(--timeline-header-day-height);
   display: flex;
   justify-content: center;
   min-width: 0;
 }
 
 .day-label {
   display: none;
   width: 100%;
   white-space: nowrap;
   overflow: hidden;
   text-overflow: ellipsis;
 }
 
 .day-label--default {
   display: block;
 }
 
 .employee-label {
-  min-width: 220px;
+  min-width: var(--timeline-sidebar-width);
   border-right: 1px solid #cbd5e1;
   border-bottom: 1px solid #f1f5f9;
   padding: 0.65rem;
   display: flex;
   align-items: center;
   justify-content: flex-start;
   background: #fcfdff;
   position: sticky;
   left: 0;
-  z-index: 6;
+  z-index: var(--timeline-sticky-sidebar-z);
   min-height: var(--timeline-row-height);
   margin: 0;
   line-height: 1.2;
 }
 
 .employee-button {
-  width: 220px;
+  width: var(--timeline-sidebar-width);
   border-top: 0;
   border-left: 0;
   border-right: 1px solid #cbd5e1;
   border-bottom: 1px solid #f1f5f9;
   cursor: pointer;
   font-weight: 600;
 }
 
 .employee-label.header {
   font-size: 0.8rem;
   font-weight: 700;
   text-transform: uppercase;
-  z-index: 9;
+  z-index: var(--timeline-sticky-corner-z);
+  background: #f8fafc;
 }
 
 .employee-row {
   display: flex;
   align-items: stretch;
   min-height: var(--timeline-row-height);
 }
 
+.department-section h2 {
+  position: sticky;
+  left: 0;
+  z-index: var(--timeline-sticky-sidebar-z);
+  margin: 0;
+  padding: 0.75rem 0.65rem;
+  width: var(--timeline-sidebar-width);
+  background: #fff;
+  border-right: 1px solid #cbd5e1;
+}
+
 .employee-timeline {
   display: flex;
   position: relative;
   min-height: var(--timeline-row-height);
 }
 
 .day-cell {
   border-left: 1px solid #f1f5f9;
   position: absolute;
   top: 0;
   bottom: 0;
 }
 
+.day-header.non-working-day,
+.day-cell.non-working-day {
+  background: var(--timeline-non-working-bg);
+}
+
 .task-block {
   position: absolute;
   top: 8px;
   bottom: 8px;
   border: 0;
   border-radius: 8px;
   color: #fff;
   display: flex;
   flex-direction: column;
   align-items: flex-start;
   justify-content: center;
   padding: 0.2rem 0.4rem;
   cursor: pointer;
   text-align: left;
   overflow: hidden;
 }
 
 .task-block-title {
   font-size: 0.72rem;
   font-weight: 700;
   white-space: nowrap;
   overflow: hidden;
   text-overflow: ellipsis;
   width: 100%;
 }
@@ -318,38 +335,39 @@ header p {
 }
 
 @media (max-width: 768px) {
   .resource-timeline-page {
     padding: 0.8rem;
   }
 
   .timeline-shell {
     max-height: calc(100vh - 220px);
   }
 
   .week-header {
     gap: 0.15rem;
   }
 
   .day-label--default {
     display: none;
   }
 
   .day-label--compact {
     display: block;
   }
 
   .employee-label,
   .employee-button {
-    min-width: 160px;
-    width: 160px;
+    --timeline-sidebar-width: 160px;
+    min-width: var(--timeline-sidebar-width);
+    width: var(--timeline-sidebar-width);
   }
 
   .modal-panel {
     width: 100vw;
   }
 
   .modal-panel dl {
     grid-template-columns: 1fr;
     gap: 0.25rem;
   }
 }
diff --git a/src/utils/dateUtils.ts b/src/utils/dateUtils.ts
index 2f4a8665894cd4c9e56991f1db877bd8d0128a13..52ba66aac240c433dff53c3217c3ff0c025fa7ec 100644
--- a/src/utils/dateUtils.ts
+++ b/src/utils/dateUtils.ts
@@ -1,41 +1,134 @@
 const DAY_IN_MS = 24 * 60 * 60 * 1000;
+const SATURDAY = 6;
+const SUNDAY = 0;
+
+const holidayCache = new Map<number, Set<string>>();
 
 export const toDate = (value: string): Date => {
   const date = new Date(`${value}T00:00:00`);
   return new Date(date.getTime() + date.getTimezoneOffset() * 60 * 1000);
 };
 
 export const formatISODate = (date: Date): string =>
   date.toISOString().slice(0, 10);
 
 export const addDays = (date: Date, days: number): Date => {
   const output = new Date(date);
   output.setDate(output.getDate() + days);
   return output;
 };
 
+const getEasterSunday = (year: number): Date => {
+  const a = year % 19;
+  const b = Math.floor(year / 100);
+  const c = year % 100;
+  const d = Math.floor(b / 4);
+  const e = b % 4;
+  const f = Math.floor((b + 8) / 25);
+  const g = Math.floor((b - f + 1) / 3);
+  const h = (19 * a + b - d - g + 15) % 30;
+  const i = Math.floor(c / 4);
+  const k = c % 4;
+  const l = (32 + 2 * e + 2 * i - h - k) % 7;
+  const m = Math.floor((a + 11 * h + 22 * l) / 451);
+  const month = Math.floor((h + l - 7 * m + 114) / 31);
+  const day = ((h + l - 7 * m + 114) % 31) + 1;
+  return new Date(year, month - 1, day);
+};
+
+const buildHolidaySetBW = (year: number): Set<string> => {
+  const easterSunday = getEasterSunday(year);
+
+  const staticHolidays = [
+    new Date(year, 0, 1),
+    new Date(year, 0, 6),
+    new Date(year, 4, 1),
+    new Date(year, 9, 3),
+    new Date(year, 10, 1),
+    new Date(year, 11, 25),
+    new Date(year, 11, 26),
+  ];
+
+  const dynamicHolidays = [
+    addDays(easterSunday, -2),
+    addDays(easterSunday, 1),
+    addDays(easterSunday, 39),
+    addDays(easterSunday, 50),
+    addDays(easterSunday, 60),
+  ];
+
+  return new Set(
+    [...staticHolidays, ...dynamicHolidays].map((holiday) => formatISODate(holiday)),
+  );
+};
+
+export const isWeekend = (date: Date): boolean => {
+  const day = date.getDay();
+  return day === SATURDAY || day === SUNDAY;
+};
+
+export const isHolidayBW = (date: Date): boolean => {
+  const year = date.getFullYear();
+  if (!holidayCache.has(year)) {
+    holidayCache.set(year, buildHolidaySetBW(year));
+  }
+
+  return holidayCache.get(year)!.has(formatISODate(date));
+};
+
+export const isWorkingDay = (date: Date): boolean => {
+  return !isWeekend(date) && !isHolidayBW(date);
+};
+
+export const getNextWorkingDay = (date: Date): Date => {
+  const output = new Date(date);
+  while (!isWorkingDay(output)) {
+    output.setDate(output.getDate() + 1);
+  }
+  return output;
+};
+
+export const addWorkingDays = (date: Date, days: number): Date => {
+  if (days === 0) {
+    return getNextWorkingDay(date);
+  }
+
+  const output = new Date(date);
+  const direction = days > 0 ? 1 : -1;
+  let remaining = Math.abs(days);
+
+  while (remaining > 0) {
+    output.setDate(output.getDate() + direction);
+    if (isWorkingDay(output)) {
+      remaining -= 1;
+    }
+  }
+
+  return output;
+};
+
 export const differenceInDays = (start: Date, end: Date): number => {
   return Math.floor((end.getTime() - start.getTime()) / DAY_IN_MS);
 };
 
 export const getDayRange = (startDate: string, totalDays: number): Date[] => {
   const start = toDate(startDate);
   return Array.from({ length: totalDays }, (_, index) => addDays(start, index));
 };
 
 export const getWeekLabel = (date: Date): string => {
   const isoWeek = getISOWeek(date);
   return `KW ${isoWeek}`;
 };
 
 export const startOfISOWeek = (date: Date): Date => {
   const output = new Date(date);
   const day = output.getDay() || 7;
   output.setDate(output.getDate() - (day - 1));
   return output;
 };
 
 export const endOfISOWeek = (date: Date): Date => {
   const output = startOfISOWeek(date);
   output.setDate(output.getDate() + 6);
   return output;
